<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>vq_batch.c — Method Overview</title>
  <link rel="stylesheet" href="style.css">
  <style>
    .method { background:#e6f2ff; padding:12px; border-left:4px solid #0366d6; margin:12px 0; }
    .method-name { font-family:monospace; font-weight:bold; color:#0366d6; }
    .method-purpose { font-weight:bold; margin:6px 0 0 0; }
    .method-detail { margin:6px 0 0 0; line-height:1.6; }
  </style>
</head>
<body>
<div class="container">
  <div class="nav"><a href="index.html">◀ Back</a></div>
  <h1>`vq_batch.c` — Method Overview</h1>
  <p class="note">This file performs Vector Quantization (VQ) in batch: it reads MFCC files, maps each frame to a codebook symbol, and writes quantized sequences to files organized by digit and train/dev split.</p>

  <h2>Core Methods</h2>

  <div class="method">
    <span class="method-name">void load_codebook(const char *filename)</span>
    <p class="method-purpose">Load the codebook vectors from a file into memory.</p>
    <p class="method-detail">Opens `codebook.txt` (which contains 32 representative MFCC vectors, each 39-dimensional). Reads all values and stores them in the global `codebook` array. If the file can't be opened, the program exits immediately because VQ cannot proceed without the codebook. This codebook was previously generated by K-means (kmeans.c, main.c).</p>
  </div>

  <div class="method">
    <span class="method-name">double squared_distance(Vector a, Vector b)</span>
    <p class="method-purpose">Compute squared Euclidean distance between two MFCC vectors.</p>
    <p class="method-detail">Same function as in kmeans.c: sums squared differences across all 39 dimensions. Used to find which codebook vector is closest to a given MFCC frame. Speed is important here since we compute this distance thousands of times (once per frame in the entire dataset).</p>
  </div>

  <div class="method">
    <span class="method-name">int vq_map(Vector frame)</span>
    <p class="method-purpose">Quantize one MFCC frame: return its nearest codebook index.</p>
    <p class="method-detail">Finds the codebook vector closest to the given frame using squared_distance. Returns the index (0–31) of that closest vector. This is the "symbol" that represents this frame for HMM purposes. Essentially, it reduces a 39-dimensional continuous vector to a single discrete integer (0–31).</p>
  </div>

  <div class="method">
    <span class="method-name">int get_class_from_name(const char *name)</span>
    <p class="method-purpose">Extract the digit class (2, 3, 4, or 5) from a filename.</p>
    <p class="method-detail">Searches the filename string for substrings "2", "3", "4", "5". Returns the matching digit, or -1 if none found. Simple heuristic: assumes filenames contain the digit they represent (e.g., `digit2_sample1.mfcc`). Used to organize output sequences into digit-specific folders.</p>
  </div>

  <div class="method">
    <span class="method-name">void process_folder(const char *mfcc_dir, const char *split)</span>
    <p class="method-purpose">Process all MFCC files in a directory, quantize them, output symbol sequences organized by digit and split.</p>
    <p class="method-detail">
      <b>Steps:</b>
      <ol>
        <li><b>Open directory:</b> Use POSIX `opendir` to read all files in `mfcc_dir` (e.g., `../../audios/combined_train` or `combined_dev`).</li>
        <li><b>For each file:</b> Skip dot-files. Extract digit class from filename. If class is 2–5, proceed.</li>
        <li><b>Create paths:</b> Build input path (full MFCC file) and output path (`hmm/<digit>/<split>.seq`).</li>
        <li><b>Read and quantize:</b> Open the MFCC file. Read frames one at a time (39 doubles per frame). Map each frame to a codebook symbol using vq_map(). Write the symbol to the output file (one line per audio file, space-separated symbols).</li>
        <li><b>Handle EOF:</b> When MFCC file is exhausted, close files and move to next input file.</li>
      </ol>
      The `split` parameter is either `"train"` or `"dev"`, used in the output filename to separate training and dev data.
    </p>
  </div>

  <div class="method">
    <span class="method-name">int main()</span>
    <p class="method-purpose">Orchestrate the full VQ batch processing pipeline.</p>
    <p class="method-detail">
      <b>Step 1:</b> Load the codebook from `codebook.txt`.
      <br><br>
      <b>Step 2:</b> Create directory structure `hmm/2, hmm/3, hmm/4, hmm/5` to hold output sequences.
      <br><br>
      <b>Step 3:</b> Call `process_folder()` twice:
      <ul>
        <li>Process training MFCC files from `../../audios/combined_train`, write to `hmm/<digit>/train.seq`.</li>
        <li>Process dev (test) MFCC files from `../../audios/combined_dev`, write to `hmm/<digit>/dev.seq`.</li>
      </ul>
      <br>
      <b>Step 4:</b> Print completion message. All MFCC data has now been converted to discrete symbol sequences, ready for HMM training.
    </p>
  </div>

  <h2>Data Flow</h2>

  <div class="concept">
    <b>Input:</b> MFCC files (one per speaker) in `combined_train` and `combined_dev` directories. Each file contains many frames (vectors).
    <br><br>
    <b>Process:</b> For each frame, find its nearest codebook entry → output that index as a symbol. Group outputs by digit and train/dev split.
    <br><br>
    <b>Output:</b> Symbol sequences in `hmm/<digit>/<split>.seq` files. Each line is one speaker's digitized audio.
    <br><br>
    <b>Next step:</b> These sequences are fed to `hmm.c` for HMM training and testing.
  </div>

  <h2>Why This Matters</h2>

  <div class="concept">
    <b>Quantization:</b> Maps continuous 39-dimensional MFCC vectors to discrete symbols (0–31). HMMs are built for discrete observations; this step is essential.
    <br><br>
    <b>Batch processing:</b> Instead of quantizing on-the-fly, we pre-compute and save all sequences. This makes training faster: no need to re-quantize repeatedly.
    <br><br>
    <b>Organization:</b> Separating data by digit and split (train/dev) makes it easy to train one HMM per digit and test independently. This is the standard way to organize classification datasets.
  </div>

  <div class="footer">For background, see <a href="fundamentals.html">Fundamentals</a> section on VQ and codebooks.</div>
</div>
</body>
</html>
