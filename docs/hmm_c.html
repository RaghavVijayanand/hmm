<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>hmm.c — Annotated</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div class="container">
  <div class="nav"><a href="index.html">◀ Back</a></div>
  <h1>`hmm.c` — Annotated</h1>
  <p class="note">HMM training and evaluation code (simple discrete HMM, Baum-Welch, forward algorithm).</p>

  <table class="code-table">
    <tr><td class="lineno">1</td><td class="code">#include &lt;stdio.h&gt;</td><td class="explain">Standard I/O for file and console operations.</td></tr>
    <tr><td class="lineno">2</td><td class="code">#include &lt;stdlib.h&gt;</td><td class="explain">Standard utilities (memory, exit, etc.).</td></tr>
    <tr><td class="lineno">3</td><td class="code">#include &lt;string.h&gt;</td><td class="explain">String manipulation functions like `strtok` used for parsing lines.</td></tr>
    <tr><td class="lineno">4</td><td class="code">#include &lt;math.h&gt;</td><td class="explain">Math functions such as `log`, used in probability computations.</td></tr>
    <tr><td class="lineno">5</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">6</td><td class="code">#define N 5          // number of states</td><td class="explain">Number of HMM states; this implementation uses a small fixed-state model.</td></tr>
    <tr><td class="lineno">7</td><td class="code">#define M 32         // number of symbols (codebook size)</td><td class="explain">Observation alphabet size (symbols from VQ/codebook).</td></tr>
    <tr><td class="lineno">8</td><td class="code">#define MAX_T 500</td><td class="explain">Maximum time steps for a sequence.</td></tr>
    <tr><td class="lineno">9</td><td class="code">#define MAX_SEQ 500</td><td class="explain">Maximum number of sequences for training or testing.</td></tr>
    <tr><td class="lineno">10</td><td class="code">#define DIGITS 4     // 2,3,4,5</td><td class="explain">Number of digit classes in this dataset (digits 2–5).</td></tr>
    <tr><td class="lineno">11</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">12</td><td class="code">// ---------------- DATA STRUCTURES ----------------</td><td class="explain">Section header for structures used to hold sequences and HMMs.</td></tr>
    <tr><td class="lineno">13</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">14</td><td class="code">typedef struct {</td><td class="explain">`Sequence` type start: holds length and symbols.</td></tr>
    <tr><td class="lineno">15</td><td class="code">    int T;</td><td class="explain">`T` is sequence length (number of time frames).</td></tr>
    <tr><td class="lineno">16</td><td class="code">    int O[MAX_T];</td><td class="explain">Observation symbols (integers) for each time frame.</td></tr>
    <tr><td class="lineno">17</td><td class="code">} Sequence;</td><td class="explain">End `Sequence` struct.</td></tr>
    <tr><td class="lineno">18</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">19</td><td class="code">typedef struct {</td><td class="explain">HMM parameter struct start.</td></tr>
    <tr><td class="lineno">20</td><td class="code">    double A[N][N];</td><td class="explain">State transition probabilities matrix (N x N).</td></tr>
    <tr><td class="lineno">21</td><td class="code">    double B[N][M];</td><td class="explain">Observation probability matrix B(state x symbol).</td></tr>
    <tr><td class="lineno">22</td><td class="code">    double pi[N];</td><td class="explain">Initial state distribution (pi[i] = P(state i at t=0)).</td></tr>
    <tr><td class="lineno">23</td><td class="code">} HMM;</td><td class="explain">End `HMM` struct.</td></tr>
    <tr><td class="lineno">24</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">25</td><td class="code">// ---------------- INITIALIZE HMM ----------------</td><td class="explain">These routines set a simple initial HMM before training.</td></tr>
    <tr><td class="lineno">26</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">27</td><td class="code">void init_hmm(HMM *hmm)</td><td class="explain">Initialize transition, observation, and initial probabilities.</td></tr>
    <tr><td class="lineno">28</td><td class="code">{</td><td class="explain"></td></tr>
    <tr><td class="lineno">29</td><td class="code">    for (int i = 0; i &lt; N; i++)</td><td class="explain">Loop over states to initialize rows of A and B and pi.</td></tr>
    <tr><td class="lineno">30</td><td class="code">    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">31</td><td class="code">        hmm->pi[i] = (i == 0);</td><td class="explain">Set `pi[0] = 1` and others to 0 — start in state 0 deterministically.</td></tr>
    <tr><td class="lineno">32</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">33</td><td class="code">        for (int j = 0; j &lt; N; j++)</td><td class="explain">Initialize transitions `A[i][j]` using a left-to-right pattern.</td></tr>
    <tr><td class="lineno">34</td><td class="code">            hmm->A[i][j] = (j == i || j == i + 1) ? 0.5 : 0.0;</td><td class="explain">Transitions allowed to stay in same state or move to next with prob 0.5 each; others 0.0. Note: last state's `i+1` index is out of bounds effectively set to 0.0.</td></tr>
    <tr><td class="lineno">35</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">36</td><td class="code">        for (int k = 0; k &lt; M; k++)</td><td class="explain">Initialize observation probabilities uniformly.</td></tr>
    <tr><td class="lineno">37</td><td class="code">            hmm->B[i][k] = 1.0 / M;</td><td class="explain">Uniform distribution over codebook symbols for each state as a neutral start.</td></tr>
    <tr><td class="lineno">38</td><td class="code">    }</td><td class="explain">End state loop.</td></tr>
    <tr><td class="lineno">39</td><td class="code">}</td><td class="explain">End `init_hmm`.</td></tr>
    <tr><td class="lineno">40</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">41</td><td class="code">// ---------------- LOAD SEQUENCES ----------------</td><td class="explain">Read symbol sequences from a whitespace-separated file, one line per sequence.</td></tr>
    <tr><td class="lineno">42</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">43</td><td class="code">int load_sequences(const char *file, Sequence *seqs)</td><td class="explain">Loads sequences into `seqs` array; returns number of sequences loaded.</td></tr>
    <tr><td class="lineno">44</td><td class="code">{</td><td class="explain"></td></tr>
    <tr><td class="lineno">45</td><td class="code">    FILE *fp = fopen(file, "r");</td><td class="explain">Open the provided file for reading.</td></tr>
    <tr><td class="lineno">46</td><td class="code">    if (!fp) return 0;</td><td class="explain">Return 0 sequences on failure to open file (caller should check).</td></tr>
    <tr><td class="lineno">47</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">48</td><td class="code">    int count = 0;</td><td class="explain">`count` will hold number of loaded sequences.</td></tr>
    <tr><td class="lineno">49</td><td class="code">    char line[4096];</td><td class="explain">Buffer to read each line; assumes sequences fit in this length.</td></tr>
    <tr><td class="lineno">50</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">51</td><td class="code">    while (fgets(line, sizeof(line), fp))</td><td class="explain">Read the file one line at a time until EOF.</td></tr>
    <tr><td class="lineno">52</td><td class="code">    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">53</td><td class="code">        Sequence *s = &seqs[count];</td><td class="explain">Pointer to the next `Sequence` slot in the array.</td></tr>
    <tr><td class="lineno">54</td><td class="code">        s->T = 0;</td><td class="explain">Initialize sequence length to zero before parsing tokens.</td></tr>
    <tr><td class="lineno">55</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">56</td><td class="code">        char *tok = strtok(line, " \n");</td><td class="explain">Tokenize the line on spaces/newlines to extract symbols as strings.</td></tr>
    <tr><td class="lineno">57</td><td class="code">        while (tok)</td><td class="explain">Loop over tokens (symbol strings) in this line.</td></tr>
    <tr><td class="lineno">58</td><td class="code">        {</td><td class="explain"></td></tr>
    <tr><td class="lineno">59</td><td class="code">            s->O[s->T++] = atoi(tok);</td><td class="explain">Convert token to integer symbol and append to sequence's observation array.</td></tr>
    <tr><td class="lineno">60</td><td class="code">            tok = strtok(NULL, " \n");</td><td class="explain">Get next token from the same line.</td></tr>
    <tr><td class="lineno">61</td><td class="code">        }</td><td class="explain">End token loop.</td></tr>
    <tr><td class="lineno">62</td><td class="code">        count++;</td><td class="explain">Increment count of loaded sequences.</td></tr>
    <tr><td class="lineno">63</td><td class="code">    }</td><td class="explain">End line-reading loop.</td></tr>
    <tr><td class="lineno">64</td><td class="code">    fclose(fp);</td><td class="explain">Close the file after reading all sequences.</td></tr>
    <tr><td class="lineno">65</td><td class="code">    return count;</td><td class="explain">Return number of sequences loaded.</td></tr>
    <tr><td class="lineno">66</td><td class="code">}</td><td class="explain">End `load_sequences` function.</td></tr>
    <tr><td class="lineno">67</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">68</td><td class="code">// ---------------- FORWARD ALGORITHM ----------------</td><td class="explain">Compute log-probability of observation sequence using forward algorithm with scaling avoided by taking log at end.</td></tr>
    <tr><td class="lineno">69</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">70</td><td class="code">double forward(HMM *hmm, Sequence *seq)</td><td class="explain">Returns log probability of `seq` under `hmm`.</td></tr>
    <tr><td class="lineno">71</td><td class="code">{</td><td class="explain"></td></tr>
    <tr><td class="lineno">72</td><td class="code">    double alpha[MAX_T][N];</td><td class="explain">Alpha matrix: forward probabilities for each time and state.</td></tr>
    <tr><td class="lineno">73</td><td class="code">    int T = seq->T;</td><td class="explain">Local copy of sequence length for convenience.</td></tr>
    <tr><td class="lineno">74</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">75</td><td class="code">    for (int i = 0; i &lt; N; i++)</td><td class="explain">Initialize alpha at time 0 for each state: alpha[0][i] = pi[i] * B[i][O0].</td></tr>
    <tr><td class="lineno">76</td><td class="code">        alpha[0][i] = hmm->pi[i] * hmm->B[i][seq->O[0]];</td><td class="explain">Probability of starting in state i and observing first symbol.</td></tr>
    <tr><td class="lineno">77</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">78</td><td class="code">    for (int t = 1; t &lt; T; t++)</td><td class="explain">For each subsequent time step, compute alpha recursively.</td></tr>
    <tr><td class="lineno">79</td><td class="code">        for (int j = 0; j &lt; N; j++)</td><td class="explain">Compute alpha[t][j] from previous alphas and transitions into j.</td></tr>
    <tr><td class="lineno">80</td><td class="code">        {</td><td class="explain"></td></tr>
    <tr><td class="lineno">81</td><td class="code">            alpha[t][j] = 0;</td><td class="explain">Initialize accumulator for state j at time t.</td></tr>
    <tr><td class="lineno">82</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain">Sum over source states i of alpha[t-1][i] * A[i][j].</td></tr>
    <tr><td class="lineno">83</td><td class="code">                alpha[t][j] += alpha[t-1][i] * hmm->A[i][j];</td><td class="explain">Add contribution from state i transitioning to j.</td></tr>
    <tr><td class="lineno">84</td><td class="code">            alpha[t][j] *= hmm->B[j][seq->O[t]];</td><td class="explain">Multiply by observation probability of symbol at time t in state j.</td></tr>
    <tr><td class="lineno">85</td><td class="code">        }</td><td class="explain">End loop over states j.</td></tr>
    <tr><td class="lineno">86</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">87</td><td class="code">    double prob = 0;</td><td class="explain">Accumulate final probabilities over all ending states.</td></tr>
    <tr><td class="lineno">88</td><td class="code">    for (int i = 0; i &lt; N; i++)</td><td class="explain">Sum alpha at final time across states to get sequence probability.</td></tr>
    <tr><td class="lineno">89</td><td class="code">        prob += alpha[T-1][i];</td><td class="explain">Add probability mass from state i at final time.</td></tr>
    <tr><td class="lineno">90</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">91</td><td class="code">    return log(prob + 1e-12);</td><td class="explain">Return log probability (small epsilon avoids log(0)).</td></tr>
    <tr><td class="lineno">92</td><td class="code">}</td><td class="explain">End `forward` function.</td></tr>
    <tr><td class="lineno">93</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">94</td><td class="code">// ---------------- BAUM-WELCH TRAINING ----------------</td><td class="explain">EM-style parameter re-estimation for discrete HMMs.</td></tr>
    <tr><td class="lineno">95</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">96</td><td class="code">void baum_welch(HMM *hmm, Sequence *seqs, int S, int iters)</td><td class="explain">Train `hmm` on `S` sequences for `iters` iterations in-place.</td></tr>
    <tr><td class="lineno">97</td><td class="code">{</td><td class="explain"></td></tr>
    <tr><td class="lineno">98</td><td class="code">    static double alpha[MAX_T][N], beta[MAX_T][N];</td><td class="explain">Static to allocate large arrays once: forward/backward tables.</td></tr>
    <tr><td class="lineno">99</td><td class="code">    static double gamma[MAX_T][N], xi[MAX_T][N][N];</td><td class="explain">Gamma (state occupancy) and xi (pairwise transitions) accumulators per time.</td></tr>
    <tr><td class="lineno">100</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">101</td><td class="code">    for (int it = 0; it &lt; iters; it++)</td><td class="explain">Outer loop over Baum-Welch iterations.</td></tr>
    <tr><td class="lineno">102</td><td class="code">    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">103</td><td class="code">        for (int s = 0; s &lt; S; s++)</td><td class="explain">Loop over training sequences.</td></tr>
    <tr><td class="lineno">104</td><td class="code">        {</td><td class="explain"></td></tr>
    <tr><td class="lineno">105</td><td class="code">            Sequence *seq = &seqs[s];</td><td class="explain">Pointer to current sequence.</td></tr>
    <tr><td class="lineno">106</td><td class="code">            int T = seq->T;</td><td class="explain">Sequence length for this example.</td></tr>
    <tr><td class="lineno">107</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">108</td><td class="code">            // Forward</td><td class="explain">Compute alpha for current sequence (same code as `forward`).</td></tr>
    <tr><td class="lineno">109</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain">Initialize alpha at time 0.</td></tr>
    <tr><td class="lineno">110</td><td class="code">                alpha[0][i] = hmm->pi[i] * hmm->B[i][seq->O[0]];</td><td class="explain">Same logic as in `forward` function.</td></tr>
    <tr><td class="lineno">111</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">112</td><td class="code">            for (int t = 1; t &lt; T; t++)</td><td class="explain">Recursive forward computation.</td></tr>
    <tr><td class="lineno">113</td><td class="code">                for (int j = 0; j &lt; N; j++)</td><td class="explain">Loop states j for each time t.</td></tr>
    <tr><td class="lineno">114</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">115</td><td class="code">                    alpha[t][j] = 0;</td><td class="explain">Initialize accumulator.</td></tr>
    <tr><td class="lineno">116</td><td class="code">                    for (int i = 0; i &lt; N; i++)</td><td class="explain">Sum contributions from previous states.</td></tr>
    <tr><td class="lineno">117</td><td class="code">                        alpha[t][j] += alpha[t-1][i] * hmm->A[i][j];</td><td class="explain">Add contribution.</td></tr>
    <tr><td class="lineno">118</td><td class="code">                    alpha[t][j] *= hmm->B[j][seq->O[t]];</td><td class="explain">Multiply by obs probability.</td></tr>
    <tr><td class="lineno">119</td><td class="code">                }</td><td class="explain">End forward recursion for time t.</td></tr>
    <tr><td class="lineno">120</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">121</td><td class="code">            // Backward</td><td class="explain">Compute beta (backward probabilities) for current sequence.</td></tr>
    <tr><td class="lineno">122</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain">Initialize beta at final time T-1 to 1 (base case).</td></tr>
    <tr><td class="lineno">123</td><td class="code">                beta[T-1][i] = 1.0;</td><td class="explain">Terminal condition: probability of future observations given final state is 1.</td></tr>
    <tr><td class="lineno">124</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">125</td><td class="code">            for (int t = T-2; t &gt;= 0; t--)</td><td class="explain">Backward recursion from T-2 down to 0.</td></tr>
    <tr><td class="lineno">126</td><td class="code">                for (int i = 0; i &lt; N; i++)</td><td class="explain">Compute beta[t][i] by summing over next states.</td></tr>
    <tr><td class="lineno">127</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">128</td><td class="code">                    beta[t][i] = 0;</td><td class="explain">Init beta accumulator.</td></tr>
    <tr><td class="lineno">129</td><td class="code">                    for (int j = 0; j &lt; N; j++)</td><td class="explain">Sum over possible next states j.</td></tr>
    <tr><td class="lineno">130</td><td class="code">                        beta[t][i] += hmm->A[i][j] *</td><td class="explain">Contribution from transition to j, observation at t+1, and beta at t+1.</td></tr>
    <tr><td class="lineno">131</td><td class="code">                                      hmm->B[j][seq->O[t+1]] *</td><td class="explain"></td></tr>
    <tr><td class="lineno">132</td><td class="code">                                      beta[t+1][j];</td><td class="explain"></td></tr>
    <tr><td class="lineno">133</td><td class="code">                }</td><td class="explain">End beta computation for time t.</td></tr>
    <tr><td class="lineno">134</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">135</td><td class="code">            // Gamma & Xi</td><td class="explain">Compute expected counts gamma and xi used to reestimate parameters.</td></tr>
    <tr><td class="lineno">136</td><td class="code">            for (int t = 0; t &lt; T-1; t++)</td><td class="explain">Gamma and xi defined for times 0..T-2 (xi needs t and t+1).</td></tr>
    <tr><td class="lineno">137</td><td class="code">            {</td><td class="explain"></td></tr>
    <tr><td class="lineno">138</td><td class="code">                double denom = 0;</td><td class="explain">Denominator for normalization when computing xi.</td></tr>
    <tr><td class="lineno">139</td><td class="code">                for (int i = 0; i &lt; N; i++)</td><td class="explain">Compute denom by summing alpha * A * B * beta over i and j.</td></tr>
    <tr><td class="lineno">140</td><td class="code">                    for (int j = 0; j &lt; N; j++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">141</td><td class="code">                        denom += alpha[t][i] * hmm->A[i][j] *</td><td class="explain"></td></tr>
    <tr><td class="lineno">142</td><td class="code">                                 hmm->B[j][seq->O[t+1]] * beta[t+1][j];</td><td class="explain"></td></tr>
    <tr><td class="lineno">143</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">144</td><td class="code">                for (int i = 0; i &lt; N; i++)</td><td class="explain">Compute gamma for each state at time t by summing xi over j.</td></tr>
    <tr><td class="lineno">145</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">146</td><td class="code">                    gamma[t][i] = 0;</td><td class="explain">Initialize gamma to zero before summation.</td></tr>
    <tr><td class="lineno">147</td><td class="code">                    for (int j = 0; j &lt; N; j++)</td><td class="explain">For each possible next state j, compute xi and add into gamma.</td></tr>
    <tr><td class="lineno">148</td><td class="code">                    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">149</td><td class="code">                        xi[t][i][j] =</td><td class="explain">Compute xi[t][i][j] as normalized joint probability of being in i then j.</td></tr>
    <tr><td class="lineno">150</td><td class="code">                            (alpha[t][i] * hmm->A[i][j] *</td><td class="explain"></td></tr>
    <tr><td class="lineno">151</td><td class="code">                             hmm->B[j][seq->O[t+1]] *</td><td class="explain"></td></tr>
    <tr><td class="lineno">152</td><td class="code">                             beta[t+1][j]) / (denom + 1e-12);</td><td class="explain">Denominator avoids division by zero; xi is normalized by `denom`.</td></tr>
    <tr><td class="lineno">153</td><td class="code">                        gamma[t][i] += xi[t][i][j];</td><td class="explain">Accumulate xi into gamma: expected occupancy of state i at time t.</td></tr>
    <tr><td class="lineno">154</td><td class="code">                    }</td><td class="explain"></td></tr>
    <tr><td class="lineno">155</td><td class="code">                }</td><td class="explain">End gamma/xi computation for time t.</td></tr>
    <tr><td class="lineno">156</td><td class="code">            }</td><td class="explain"></td></tr>
    <tr><td class="lineno">157</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">158</td><td class="code">            // Update pi</td><td class="explain">Re-estimate initial distribution `pi` from gamma at time 0.</td></tr>
    <tr><td class="lineno">159</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">160</td><td class="code">                hmm->pi[i] = gamma[0][i];</td><td class="explain">Set `pi[i]` to expected probability of starting in state i.</td></tr>
    <tr><td class="lineno">161</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">162</td><td class="code">            // Update A</td><td class="explain">Re-estimate transition probabilities by normalizing expected transitions.</td></tr>
    <tr><td class="lineno">163</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">164</td><td class="code">                for (int j = 0; j &lt; N; j++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">165</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">166</td><td class="code">                    double num = 0, den = 0;</td><td class="explain">Accumulators for numerator (expected i->j transitions) and denominator (expected i occupancy).</td></tr>
    <tr><td class="lineno">167</td><td class="code">                    for (int t = 0; t &lt; T-1; t++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">168</td><td class="code">                    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">169</td><td class="code">                        num += xi[t][i][j];</td><td class="explain">Sum expected i->j counts across time.</td></tr>
    <tr><td class="lineno">170</td><td class="code">                        den += gamma[t][i];</td><td class="explain">Sum expected occupancy of i across time (except T-1).</td></tr>
    <tr><td class="lineno">171</td><td class="code">                    }</td><td class="explain"></td></tr>
    <tr><td class="lineno">172</td><td class="code">                    hmm->A[i][j] = num / (den + 1e-12);</td><td class="explain">Update A entry with small epsilon to avoid division by zero.</td></tr>
    <tr><td class="lineno">173</td><td class="code">                }</td><td class="explain"></td></tr>
    <tr><td class="lineno">174</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">175</td><td class="code">            // Update B</td><td class="explain">Re-estimate observation probabilities per state and symbol.</td></tr>
    <tr><td class="lineno">176</td><td class="code">            for (int i = 0; i &lt; N; i++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">177</td><td class="code">                for (int k = 0; k &lt; M; k++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">178</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">179</td><td class="code">                    double num = 0, den = 0;</td><td class="explain">Numerator counts occurrences of symbol k in state i; denominator is expected occupancy.</td></tr>
    <tr><td class="lineno">180</td><td class="code">                    for (int t = 0; t &lt; T; t++)</td><td class="explain"></td></tr>
    <tr><td class="lineno">181</td><td class="code">                    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">182</td><td class="code">                        if (seq->O[t] == k)</td><td class="explain">If the observed symbol at time t equals k, add expected occupancy.</td></tr>
    <tr><td class="lineno">183</td><td class="code">                            num += gamma[t][i];</td><td class="explain">Add gamma if the symbol matches k (expected count of being in i when observing k).</td></tr>
    <tr><td class="lineno">184</td><td class="code">                        den += gamma[t][i];</td><td class="explain">Denominator accumulates expected occupancy of state i for all t.</td></tr>
    <tr><td class="lineno">185</td><td class="code">                    }</td><td class="explain"></td></tr>
    <tr><td class="lineno">186</td><td class="code">                    hmm->B[i][k] = num / (den + 1e-12);</td><td class="explain">Update B entry for state i and symbol k.</td></tr>
    <tr><td class="lineno">187</td><td class="code">                }</td><td class="explain"></td></tr>
    <tr><td class="lineno">188</td><td class="code">        }</td><td class="explain">End per-sequence processing loop.</td></tr>
    <tr><td class="lineno">189</td><td class="code">    }</td><td class="explain">End iterations loop.</td></tr>
    <tr><td class="lineno">190</td><td class="code">}</td><td class="explain">End `baum_welch` function.</td></tr>
    <tr><td class="lineno">191</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">192</td><td class="code">// ---------------- MAIN (TRAIN + TEST + ACCURACY) ----------------</td><td class="explain">High-level program that trains HMMs per digit and evaluates accuracy on dev data.</td></tr>
    <tr><td class="lineno">193</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">194</td><td class="code">int main()</td><td class="explain">Program entry for HMM training/testing example — separate from the K-means `main.c`.</td></tr>
    <tr><td class="lineno">195</td><td class="code">{</td><td class="explain"></td></tr>
    <tr><td class="lineno">196</td><td class="code">    int labels[DIGITS] = {2,3,4,5};</td><td class="explain">Array of digit labels corresponding to models we will build and test.</td></tr>
    <tr><td class="lineno">197</td><td class="code">    HMM models[DIGITS];</td><td class="explain">Array to store one HMM per digit class.</td></tr>
    <tr><td class="lineno">198</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">199</td><td class="code">    // TRAINING</td><td class="explain">Training loop over each digit's training sequences.</td></tr>
    <tr><td class="lineno">200</td><td class="code">    for (int d = 0; d &lt; DIGITS; d++)</td><td class="explain">Loop over digit classes.</td></tr>
    <tr><td class="lineno">201</td><td class="code">    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">202</td><td class="code">        char path[128];</td><td class="explain">Buffer to hold file paths for train/dev files for each digit.</td></tr>
    <tr><td class="lineno">203</td><td class="code">        Sequence train[MAX_SEQ];</td><td class="explain">Array to load training sequences for this digit.</td></tr>
    <tr><td class="lineno">204</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">205</td><td class="code">        sprintf(path, "hmm/%d/train.seq", labels[d]);</td><td class="explain">Construct the path to training sequences for this digit (e.g., `hmm/2/train.seq`).</td></tr>
    <tr><td class="lineno">206</td><td class="code">        int S = load_sequences(path, train);</td><td class="explain">Load sequences into `train`, `S` is the number loaded.</td></tr>
    <tr><td class="lineno">207</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">208</td><td class="code">        init_hmm(&models[d]);</td><td class="explain">Initialize model parameters for this digit before training.</td></tr>
    <tr><td class="lineno">209</td><td class="code">        baum_welch(&models[d], train, S, 15);</td><td class="explain">Train model with Baum-Welch for 15 iterations (chosen heuristically).</td></tr>
    <tr><td class="lineno">210</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">211</td><td class="code">        printf("Trained HMM for digit %d\n", labels[d]);</td><td class="explain">Log which digit model finished training.</td></tr>
    <tr><td class="lineno">212</td><td class="code">    }</td><td class="explain">End training loop.</td></tr>
    <tr><td class="lineno">213</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">214</td><td class="code">    // TESTING</td><td class="explain">Evaluate models against dev sequences and compute accuracy.</td></tr>
    <tr><td class="lineno">215</td><td class="code">    int correct = 0, total = 0;</td><td class="explain">Counters for accuracy calculation.</td></tr>
    <tr><td class="lineno">216</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">217</td><td class="code">    for (int d = 0; d &lt; DIGITS; d++)</td><td class="explain">Loop over each true digit class for testing.</td></tr>
    <tr><td class="lineno">218</td><td class="code">    {</td><td class="explain"></td></tr>
    <tr><td class="lineno">219</td><td class="code">        char path[128];</td><td class="explain">Path buffer for dev file for this digit.</td></tr>
    <tr><td class="lineno">220</td><td class="code">        Sequence test[MAX_SEQ];</td><td class="explain">Array to hold dev sequences loaded from file.</td></tr>
    <tr><td class="lineno">221</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">222</td><td class="code">        sprintf(path, "hmm/%d/dev.seq", labels[d]);</td><td class="explain">Construct dev path for the current true label.</td></tr>
    <tr><td class="lineno">223</td><td class="code">        int S = load_sequences(path, test);</td><td class="explain">Load dev sequences count into `S`.</td></tr>
    <tr><td class="lineno">224</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">225</td><td class="code">        for (int s = 0; s &lt; S; s++)</td><td class="explain">Evaluate each sequence in the dev set for this true digit.</td></tr>
    <tr><td class="lineno">226</td><td class="code">        {</td><td class="explain"></td></tr>
    <tr><td class="lineno">227</td><td class="code">            double best = -1e18;</td><td class="explain">Keep track of best log-probability seen so far for classification.</td></tr>
    <tr><td class="lineno">228</td><td class="code">            int pred = -1;</td><td class="explain">Predicted label for the sequence initialized to invalid value.</td></tr>
    <tr><td class="lineno">229</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">230</td><td class="code">            for (int m = 0; m &lt; DIGITS; m++)</td><td class="explain">Score this sequence under each trained model and pick the highest.</td></tr>
    <tr><td class="lineno">231</td><td class="code">            {</td><td class="explain"></td></tr>
    <tr><td class="lineno">232</td><td class="code">                double p = forward(&models[m], &test[s]);</td><td class="explain">Compute log-probability of `test[s]` under model `m`.</td></tr>
    <tr><td class="lineno">233</td><td class="code">                if (p &gt; best)</td><td class="explain">If this model produces higher log-probability, update best/pred.</td></tr>
    <tr><td class="lineno">234</td><td class="code">                {</td><td class="explain"></td></tr>
    <tr><td class="lineno">235</td><td class="code">                    best = p;</td><td class="explain">Update highest score.</td></tr>
    <tr><td class="lineno">236</td><td class="code">                    pred = labels[m];</td><td class="explain">Record predicted label (digit) for this model index.</td></tr>
    <tr><td class="lineno">237</td><td class="code">                }</td><td class="explain"></td></tr>
    <tr><td class="lineno">238</td><td class="code">            }</td><td class="explain">End model scoring loop.</td></tr>
    <tr><td class="lineno">239</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">240</td><td class="code">            if (pred == labels[d])</td><td class="explain">If predicted label matches true label, count as correct.</td></tr>
    <tr><td class="lineno">241</td><td class="code">                correct++;</td><td class="explain"></td></tr>
    <tr><td class="lineno">242</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">243</td><td class="code">            total++;</td><td class="explain">Increment total tested examples.</td></tr>
    <tr><td class="lineno">244</td><td class="code">        }</td><td class="explain">End per-sequence evaluation for this digit.</td></tr>
    <tr><td class="lineno">245</td><td class="code">    }</td><td class="explain">End loop over true digit classes.</td></tr>
    <tr><td class="lineno">246</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">247</td><td class="code">    printf("\nAccuracy = %.2f%% (%d / %d)\n",
           100.0 * correct / total, correct, total);</td><td class="explain">Print accuracy percentage and counts; uses `correct/total` ratio.</td></tr>
    <tr><td class="lineno">248</td><td class="code"> </td><td class="explain"></td></tr>
    <tr><td class="lineno">249</td><td class="code">    return 0;</td><td class="explain">Return success.</td></tr>
    <tr><td class="lineno">250</td><td class="code">}</td><td class="explain">End of HMM `main` program.</td></tr>
  </table>
</div>
</body>
</html>
